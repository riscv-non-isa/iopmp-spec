[[Registers]]
== Registers
If an optional register is not implemented, the behavior is implementation-dependent unless otherwise specified. An optional field in an implemented register means being WARL. If it is not programmable, it should be hardwired to value matching its meaning and should not cause any effect when written. Reserved regions are reserved for standard use. The behavior in the reserved regions is implementation-dependent.

.Register summary
[cols="<3,<6,<14",options="header"]
|===
|OFFSET |Register |Description

.16+|0x0000  2+|{set:cellbgcolor:#D3D3D3} INFO
|{set:cellbgcolor:#FFFFFF} VERSION |Indicates the specification and the IP vendor.
|IMPLEMENTATION | Indicates the implementation version.
| HWCFG0 |Indicates the basic configurations of current IOPMP instance.
| HWCFG1 |Indicates the supported numbers of RRIDs and entries.
| ENTRYOFFSET |Indicates the internal address offsets of each table.

| - | Other regions in offset 0x0000 to 0x0800 are reserved for standard use.

2+|{set:cellbgcolor:#D3D3D3} Configuration Protection
|{set:cellbgcolor:#FFFFFF} MDLCK/MDLCKH | Lock registers for SRCMD Table.
| MDCFGLCK | Lock register for MDCFG Table.
| ENTRYLCK | Lock register for IOPMP entry array.

2+|{set:cellbgcolor:#D3D3D3} Error Reporting
|{set:cellbgcolor:#FFFFFF} ERR_CFG | Indicates the reactions for the violations
| ERR_INFO | Indicates the information regarding captured violations.
|ERR_REQID   | Indicates the RRID and entry index regarding the first captured violation.
| ERR_REQADDR/ERR_REQADDRH | Indicates request address regarding the first captured violation.

.3+|0x0800 2+|{set:cellbgcolor:#D3D3D3} MDCFG Table,  _m_ = 0...*HWCFG0.md_num*-1
|{set:cellbgcolor:#FFFFFF}MDCFG(_m_)  |MD config register, which specifies the indices of IOPMP entries belonging to a MD.
|{set:cellbgcolor:#FFFFFF} - |Other regions in offset 0x0800 to 0x1000 are reserved for standard use.

.3+|0x1000 2+|{set:cellbgcolor:#D3D3D3} SRCMD Table, _s_ = 0...*HWCFG1.rrid_num*-1
|{set:cellbgcolor:#FFFFFF}SRCMD_EN(_s_)/SRCMD_ENH(_s_)    |The bitmapped MD enabling register of the requestor _s_ that *SRCMD_EN(_s_)[_m_]* indicates if the requestor is associated with MD _m_ and *SRCMD_ENH(_s_)[_m_]* indicates if the requestor is associated with MD (_m_+31).
|{set:cellbgcolor:#FFFFFF} - |Other regions in offset 0x1000 to ENTRYOFFSET are reserved for standard use.

.4+|ENTRYOFFSET    2+|{set:cellbgcolor:#D3D3D3} Entry Array, _i_ =0â€¦*HWCFG1.entry_num*-1
|{set:cellbgcolor:#FFFFFF}ENTRY_ADDR(_i_)| Bit 33:2 of address (region) for entry _i_.
|ENTRY_ADDRH(_i_) |(Optional) bit 65:34 of the address (region) for entry _i_. 
|ENTRY_CFG(_i_) |The configuration of entry _i_.
|===

=== *INFO registers*

INFO registers are use to indicate the IOPMP instance configuration info.
{set:cellbgcolor:#0000}
[cols="<2,<1,<1,<1,<6"]
|===
5+h|VERSION{set:cellbgcolor:#D3D3D3}
5+h|0x0000
h|Field                         |Bits   |R/W   |Default    |Description
|{set:cellbgcolor:#FFFFFF}vendor|23:0   |R     |IMP        |The JEDEC manufacturer ID.
|specver                        |31:24  |R     |IMP        |The specification version. Bits 27:24 hold the major version and bits 31:28 hold the minor version. For example, version 1.0 is reported as 0x10.
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|IMPLEMENTATION{set:cellbgcolor:#D3D3D3}
5+h|0x0004
h|Field                         |Bits   |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}impid |31:0   |R      |IMP        |The  user-defined implementation ID.
|===

[#HWCFG0]
[cols="<2,<1,<1,<1,<6"]
|===
5+h|HWCFG0{set:cellbgcolor:#D3D3D3}
5+h|0x0008
h|Field                         |Bits   |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}rsv1                         |31:4    |ZERO   |0          |Must be zero on write, reserved for future
|md_num                         |3:0    |R      |IMP        |Indicate the supported number of MD in the instance
|addrh_en                       |4:4    |R      |IMP        |Indicate if *ENTRY_ADDRH(_i_)* and *ERR_REQADDRH* are available.
|enable                         |5:5    |W1SS   |0          |Indicate if the IOPMP checks transactions by default. If it is implemented, it should be initial to 0 and sticky to 1. If it is not implemented, it should be wired to 1.
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|HWCFG1{set:cellbgcolor:#D3D3D3}
5+h|0x000C
h|Field                         |Bits   |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}rrid_num |15:0 |R      |IMP        |Indicate the supported number of RRID in the instance
|entry_num                      |31:16  |R      |IMP        |Indicate the supported number of entries in the instance, which should be larger than zero.
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|ENTRYOFFSET{set:cellbgcolor:#D3D3D3}
5+h|0x0014
h|Field                         |Bits   |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}offset|31:0   |R      |IMP        |Indicate the offset address of the IOPMP array from the base of an IOPMP instance, a.k.a. the address of *VERSION*. Note: the offset is a signed number in two's complement representation. That is, the IOPMP array can be placed in front of *VERSION*.  
|===

=== *Configuration Protection Registers*

*MDLCK* and *MDLCKH* are registers with a bitmap field to indicate which MDs are locked in the SRCMD Table. 

[cols="<2,<1,<1,<1,<6"]
|===
5+h|MDLCK{set:cellbgcolor:#D3D3D3}
5+h|0x0040
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}l     |0:0        |W1SS   |0          | Lock bit to *MDLCK* and *MDLCKH* register.
|md                             |31:1       |WARL   |0          | *md[_m_]* is sticky to 1 and indicates if *SRCMD_EN(_s_).md[_m_]* is locked for all RRID _s_. 
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} MDLCKH
5+h|0x0044
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}mdh   |31:0       |WARL   |0          | *mdh[_m_]* is sticky to 1 and indicates if *SRCMD_ENH(_s_).mdh[_m_]* is locked for all RRID _s_.
|===

*MDCFGLCK* is the lock register to MDCFG Table.

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} MDCFGLCK
5+h|0x0048
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}l     |0:0        |W1SS    |0          | Lock bit to *MDCFGLCK* register.
|f                              |6:1        |WARL     |IMP        | Indicate the number of locked MDCFG entries - *MDCFG(_m_)* is locked for _m_ < *f*. 
On write, the field only accepts the value larger than the previous value until the next reset cycle; otherwise, there is no effect.
|{set:cellbgcolor:#FFFFFF}rsv    |31:7       |ZERO   |0         | Must be zero on write, reserved for future
|===

*ENTRYLCK* is the lock register to entry array.

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ENTRYLCK
5+h|0x004C
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}l     |0:0        |W1SS   |0          | Lock bit to *ENTRYLCK* register.
|{set:cellbgcolor:#FFFFFF}f     |16:1       |WARL   |IMP        | Indicate the number of locked IOPMP entries - *ENTRY_ADDR(_i_)*, *ENTRY_ADDRH(_i_)*, and *ENTRY_CFG(_i_)* are locked for _i_ < *f*. On write, the field only accepts the value larger than the previous value until the next reset cycle; otherwise, there is no effect.
|{set:cellbgcolor:#FFFFFF}rsv    |31:17       |ZERO   |0 | Must be zero on write, reserved for future
|===

=== *Error Capture Registers*

*ERR_CFG* is a read/write WARL register used to configure the global error reporting behavior on an IOPMP violation.

[#ERR_CFG]
[cols="<2,<1,<1,<1,<6"]
|===
5+h|ERR_CFG{set:cellbgcolor:#D3D3D3}
5+h|0x0060
h|Field                           |Bits   |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}l       |0:0    |W1SS   |0          |Lock bit to *ERR_CFG* register.
|{set:cellbgcolor:#FFFFFF}ie      |1:1    |RW     |0          |Enable the interrupt of the IOPMP rule violation.
|{set:cellbgcolor:#FFFFFF}rs      |2:2    |WARL   |0         a| 

To suppress an error response on an IOPMP rule violation.

* 0x0: respond an implementation-dependent error, such as a bus error
* 0x1: respond a success with a pre-defined value to the initiator instead of an error
|{set:cellbgcolor:#FFFFFF}rsv     |31:3   |ZERO   |0     | Must be zero on write, reserved for future
|===


*ERR_INFO* captures more detailed error information.
[#REG_ERR_INFO]
[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ERR_INFO
5+h|0x0064
h|Field                         |Bits       |R/W    |Default    |Description

|{set:cellbgcolor:#FFFFFF}v    |0:0    |R     |0      | Indicate if the illegal capture recorder (*ERR_REQID*, *ERR_REQADDR*, *ERR_REQADDRH*, *ERR_INFO.ttype*, and *ERR_INFO.etype*) has a valid content and will keep the content until the bit is cleared. An interrupt will be triggered if a violation is detected and related interrupt enable/supression configure bits are not disabled, the interrupt will keep asserted until the error valid is cleared.
|{set:cellbgcolor:#FFFFFF}v    |0:0    |W1C   |N/A     | Write 1 clears the bit, the illegal recorder reactivates and the interrupt (if enabled). Write 0 causes no effect on the bit.
|{set:cellbgcolor:#FFFFFF} ttype     |2:1   |R      |0          a|{set:cellbgcolor:#FFFFFF} Indicated the transaction type of the first captured violation

- 0x00 = reserved
- 0x01 = read access
- 0x02 = write acces/AMO
- 0x03 = instruction fetch

|{set:cellbgcolor:#FFFFFF} etype     |7:4   |R      |0          a| {set:cellbgcolor:#FFFFFF} Indicated the type of violation

- 0x00 = no error
- 0x01 = illegal read access
- 0x02 = illegal write access/AMO
- 0x03 = illegal instruction fetch
- 0x04 = partial hit on a priority rule
- 0x05 = not hit any rule
- 0x06 = unknown RRID
- 0x07 = reserved
- 0x08 ~ 0x0F = reserved for future

|{set:cellbgcolor:#FFFFFF} rsv   |31:8    |ZERO      |0          |Must be zero on write, reserved for future
|===
When the bus matrix doesn't have a signal to indicate an instruction fetch, the *ttype* and *etype* can never return "instruction fetch" (0x03) and "illegal instruction fetch" (0x03), respectively.

*ERR_REQADDR* and *ERR_REQADDRH* indicate the errored request address of the first captured violation.

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ERR_REQADDR
5+h|0x0068
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}addr  |31:0       |R      |DC         |Indicate the errored address[33:2]
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ERR_REQADDRH
5+h|0x006C
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}addrh |31:0       |R      |DC         |Indicate the errored address[65:34]
|===
*ERR_REQID* indicates the errored RRID and entry index of the first captured violation.
[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ERR_REQID
5+h|0x0070
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}rrid  |15:0       |R      |DC        |Indicate the errored RRID.
|{set:cellbgcolor:#FFFFFF}eid   |31:16  |R      |DC          |Indicates the index pointing to the entry that catches the violation. If no entry is hit, that is, *etype*=0x05, 0x06 or 0x07, the value of this field is invalid. If the field is not implemented, it should be wired to 0xffff.
|===


=== *MDCFG Table Registers*
MDCFG Table is a lookup to specify the number of IOPMP entries that is associated with each MD.

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} MDCFG(_m_), _m_ = 0...HWCFG0.md_num-1, support up to 63 MDs
5+h|0x0800 + (_m_)*4
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}t     |15:0       |WARL   |DC/IMP         a| Indicate the encoding the range of memory domain _m_. An IOPMP entry with index _j_ belongs to MD _m_                 
      
- If *MDCFG(_m_-1).t* â‰¤ _j_ < *MDCFG(_m_).t,* where m > 0.
- If _j_ < *MDCFG(0).t* where m = 0.
- If *MDCFG(_m_-1).t* > *MDCFG(_m_).t*, then MDCFG Table is improperly programmed. Please refer <<#SECTION_3_3_1, MDCFG Table Format 0>> for IOPMP behavior of improperly programming.

|{set:cellbgcolor:#FFFFFF}rsv    |31:16       |ZERO   |0 |Must be zero on write, reserved for future 
|===


=== *SRCMD Table Registers*

*SRCMD_EN(_s_)* and *SRCMD_ENH(_s_)* are the SRCMD Table registers.

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} SRCMD_EN(_s_), _s_ = 0...HWCFG1.rrid_num-1
5+h|0x1000 + (_s_)*32
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}l     |0:0        |W1SS     |0          | A sticky lock bit. When set, locks *SRCMD_EN(_s_)* and *SRCMD_ENH(_s_)*.
|md                             |31:1       |WARL   |DC         | *md[_m_]* = 1 indicates MD _m_ is associated with RRID _s_.
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} SRCMD_ENH(_s_), _s_ = 0...HWCFG1.rrid_num-1
5+h|0x1004 + (_s_)*32
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}mdh   |31:0       |WARL   |DC         | *mdh[_m_]* = 1 indicates MD (_m_+31) is associated with RRID _s_.
|===


=== *Entry Array Registers*
[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ENTRY_ADDR(_i_), _i_ = 0...HWCFG1.entry_num-1
5+h|ENTRYOFFSET + (_i_)*16
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}addr  |31:0       |WARL   |DC |The physical address[33:2] of protected memory region. 
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ENTRY_ADDRH(_i_), _i_ = 0...HWCFG1.entry_num-1
5+h|ENTRYOFFSET + 0x4 + (_i_)*16
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}addrh |31:0       |WARL   |DC |The physical address[65:34] of protected memory region. 
|===
A complete 64-bit address consists of these two registers, *ENTRY_ADDR* and *ENTRY_ADDRH*. However, an IOPMP can only manage a segment of space, so an implementation would have a certain number of the most significant bits that are the same among all entries. These bits are allowed to be hardwired.

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ENTRY_CFG(_i_), _i_ = 0...HWCFG1.entry_num-1
5+h|ENTRYOFFSET + 0x8 + (_i_)*16
h|Field                         |Bits       |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}r     |0:0        |WARL   |DC         |The read permission to protected memory region 
|w                              |1:1        |WARL   |DC         |The write permission to the protected memory region
|a                              |4:3        |WARL   |DC         a|The address mode of the IOPMP entry

* 0x0: OFF
* 0x1: TOR
* 0x2: NA4
* 0x3: NAPOT
|{set:cellbgcolor:#FFFFFF}rsv |31:5       |ZERO   |0 |Must be zero on write, reserved for future
|===

Bits *r* and *w* grant read and write permission, respectively. Not each bit should be programmable. Some or all of them could be wired. Besides, an implementation can optionally impose constraints on their combinations.
