[[IOPMP_Tables_and_Configuration_Protection]]
== IOPMP Tables and Configuration Protection
The spec offers several IOPMP configurations to accommodate varied platforms. Users can choose one that best fits their design requirements, such as area, power consumption, latency, throughput, flexibility, and portability.

[#SECTION_3_1]
=== SRCMD Table and MDCFG Table
When a IOPMP receives a transaction with RRID _s_, IOPMP first lookups SRCMD Table to find out all the memory domains associated to requestor _s_. An IOPMP instance can support up to 65,535 requestors, the actual number of requestor can be implementation-defined and is indicated in *HWCFG1.rrid_num*. The SRCMD Table defines the mapping from a transaction requestor to its associated MDs.

When the associated memory domains are retrieved, an IOPMP finds the entries. The MDCFG defines which memory domain every entry belongs to. An entry can belong to at most one memory domain, but a memory domain can own zero or more entries.

After retrieving all related entries, an IOPMP checks the transaction according to them.

[#SECTION_3_2]
=== SRCMD Table
// NOTE: This section was simplified from the original "SRCMD Table Formats" which included Format 0, Format 1, and Format 2.
// Only the full model (equivalent to Format 0) is now supported in the simplified specification.

The SRCMD Table is an array indexed by RRID that associates each requestor with its memory domains. The table uses a bitmap approach where each RRID can be associated with multiple memory domains.

The register *SRCMD_EN(_s_)* must be implemented for each existing RRID _s_. Every bit in the 31-bit field *SRCMD_EN(_s_).md* indicates a memory domain. Bit _j_ in *SRCMD_EN(_s_).md* indicates if MD _j_ is associated with RRID _s_. If the number of MDs is more than 31, the register *SRCMD_ENH(_s_)* and its 32-bit field *SRCMD_ENH(_s_).mdh* can be implemented to support up to 63 memory domains. Bit _j_ in *SRCMD_ENH(_s_).mdh* indicates if MD (_j_ + 31) is associated with RRID _s_. For unimplemented memory domains, the corresponding bits should be hardwired read-only zero.

Every *SRCMD_EN(_s_)* has 1-bit field *l* for SRCMD Table protection. The bit is described in <<#SECTION_3_5_1, SRCMD Table Protection>>.

[#SECTION_3_3]

=== MDCFG Table
// NOTE: This section was simplified from the original which included Format 0, Format 1, and Format 2.
// Only Format 0 (the full model) is now supported in the simplified specification.
The MDCFG Table is used to map a memory domain to its own entries. It can be viewed as a partition of all entries in the IOPMP. In the MDCFG Table, every memory domain _m_ has a register, *MDCFG(_m_)*. Field *MDCFG(_m_).t* represents the upper bound (not included) and field *MDCFG(_m_-1).t* represents the lower bound (included) for _m_ > 0. They form the index range of IOPMP entries belonging to the memory domain _m_. That is,


* an entry with index _j_ belongs to MD _m_ if *MDCFG(_m_ - 1).t* &#8804; _j_ < *MDCFG(_m_).t*, where _m_ > 0.
* an entry with index _j_ belongs to MD 0 if _j_ < *MDCFG(0).t*.

Programmers should maintain proper settings in the MDCFG Table, where *MDCFG(_m_ + 1).t* should be greater than or equal to *MDCFG(_m_).t* for any legal MD m. Otherwise, the MDCFG table has an improper setting, that is, there exist two legal MDs _m_ and _k_, *MDCFG(_k_).t* > *MDCFG(_m_).t* for _k_ < _m_. In this case, we denote the MD _m_ has an improper setting.

When the MDCFG Table has any improper setting, the belonging of IOPMP entries is implementation-dependent, but the following conditions should be held:

* an entry must belong to at most one memory domain; and
* the index of an entry in a lower-indexed memory domain should be lower than that in a higher-indexed memory domain.

[NOTE]
====
For portability, programmers should ensure the MDCFG Table has a proper setting during the runtime. In the case that the process of programming or initializing the MDCFG Table causes an improper setting to occur transiently, one can deassociate effected MDs in SRCMD table before programming MDCFG table to avoid security issues. Even though the procedure may introduce extra steps, the table is not subject to change at a high frequency to hurt overall performance. Thus, the specification requires programmers to maintain a proper setting instead of requiring specific hardware behaviors on improper settings.
====

[NOTE]
====
Here are some reference behaviors for an improper setting, which may include, but are not limited to:

. correct the values to make the table have a proper setting,
. reject the write access to make an improper setting, or
. leave the improper setting in the MDCFG Table, but the belonging of entries for all MDs _m_ having an improper setting becomes:
.. no entry belongs to MD _m_, or
.. no entry belongs to all MDs _m_ to (*HWCFG0.md_num* - 1).

====



// NOTE: Section 3.4 "IOPMP Models" was removed as part of the specification simplification.
// The original section described rapid-k, dynamic-k, isolation, and compact-k models.
// Only the full model is now supported in the simplified specification.

[#SECTION_3_4]
=== Configuration Protection
The term 'lock' refers to a hardware feature that renders one or more fields or registers nonprogrammable until the IOPMP is reset. This feature serves to maintain the integrity of essential configurations in the event of a compromise of secure software. In cases where a lock bit is programmable, it is expected to be reset to '0' and is a W1SS field.

[#SECTION_3_5_1]
==== SRCMD Table Protection
In Format 0, every *SRCMD_EN(_s_)* register has a bit *l* at bit 0, which is used to lock registers *SRCMD_EN(_s_)*, and *SRCMD_ENH(_s_)* if any.

The two fields *MDLCK.md* and *MDLCKH.mdh* have 63 bits together. Every bit is used to lock the association bits with a memory domain in the SRCMD Table. In Format 0, for MD 0 &#x2264; _m_ &#x2264; 30, *MDLCK.md[_m_]* locks *SRCMD(_s_).md[_m_]* for all existing RRID _s_. In Format 1, there is no *MDLCK*. In Format 2, *MDLCK.md[_m_]* locks both *SRCMD_PERM(_m_)* and *SRCMD_PERMH(_m_)*. For MD 31 &#x2264; _m_ &#x2264; 62, one should use *MDLCKH.mdh* to lock corresponding bits.

Bit *MDLCK.l* is a sticky to 1 and indicates if *MDLCK* and *MDLCKH* are locked.

*MDLCK.md* is optional, if not implemented, *MDLCK.md* should be wired to 0 and *MDLCK.l* should be wired to 1. *MDLCKH* is optional.

[NOTE]
====
Locking SRCMD Table in either way can prevent the table from being altered accidentally or maliciously.
By locking the association of the MD containing the configuration regions of a component, one can prevent the component from being configured by unwanted RRIDs. To make it more secure, one can use another high-priority MD containing the same regions but no permission, let it be associated with all unwanted RRIDs, and then lock the two MDs' associations by *MDLCK*/*MDLCKH*. By adopting this approach, it is possible to safeguard the configuration from direct access by potentially compromised security software.
====

[#SECTION_3_5_2]
==== MDCFG Table Protection
Register *MDCFGLCK* is designed to partially or fully lock the MDCFG Table for Format 0. *MDCFGLCK* consists of two fields: *MDCFGLCK.l* and *MDCFGLCK.f*. *MDCFG(_m_)* is locked if _m_< *MDCFGLCK.f*. *MDCFGLCK.f* is incremental-only. Any smaller value can not be written into it. The bit *MDCFGLCK.l* is used to lock *MDCFGLCK*.

Format 1 and 2 do not implement the register *MDCFGLCK*.

[NOTE]
====
If *MDCFG(_m_)* is locked for MD _m_, while *MDCFG(_m_-1)* is not locked, it could lead to the potential addition or removal of unexpected IOPMP entries within the MD _m_. This can occur by manipulating *MDCFG(_m_-1).t*. Thus, the specification requires that *MDCFG(_m_)* is locked for MD _m_, all its preceding MDCFG Table entries (*MDCFG(0)* to *MDCFG(_m_-1)*) should be locked.
====

[#SECTION_3_5_3]
==== Entry Protection
IOPMP entry protection is also related to the other IOPMP entries belonging to the same memory domain. For a MD, locked entries should be placed in the higher priority. Otherwise, when the secure monitor is compromised, one unlocked entry in higher priority can overwrite all the other locked or non-locked entries in lower priority.  A register *ENTRYLCK* is defined to indicate the number of nonprogrammable entries. *ENTRYLCK* register has two fields: *ENTRYLCK.l* and *ENTRYLCK.f*. Any IOPMP entry with index _i_ < *ENTRYLCK.f* is not programmable. *ENTRYLCK.f* is incremental-only. Any smaller value can not be written into it. Besides, *ENTRYLCK.l* is the lock to *ENTRYLCK.f* and itself. If *ENTRYLCK* is hardwired, *ENTRYLCK.l* should be wired to 1.

[#SECTION_3_5_4]
==== Summary of Table, Register, and Field Locks

Almost all programmable tables, registers, and fields have a corresponding lock mechanism that prevents updates until the IOPMP is reset. The following is a summary.

* <<#SECTION_3_5_1, SRCMD Table Protection>> - locks for the SRCMD Table.
* <<#SECTION_3_5_2, MDCFG Table Protection>> - locks for the MDCFG Table.
* <<#SECTION_3_5_3, Entry Protection>> - locks for the IOPMP entry array.

[NOTE]
====
Error record registers do not have corresponding locks, as they are intended to be modified at runtime.
====

[#SECTION_3_6]
=== Prelocked Configurations
Prelocked configurations in the specification mean the fields or registers are locked right after reset. In practice, they could be hardwired and/or implemented by read-only memory. Every lock mechanism in this chapter can be optionally pre-locked.
The non-zero reset value of *MDCFGLCK.f* reflects the pre-locked *MDCFG(_j_)*, where _j_< *MDCFGLCK.f*. The non-zero reset value of *ENTRYLCK.f* reflects the existing pre-locked entries. *SRCMD_EN(H)* can have prelocked bits fully or partially based on presets of *MDLCK.md* and *SRCMD_EN.l*. In Format 2, the SRCMD Table can be prelocked fully or partially based on the presets of *MDLCK.md*.
The rest of the lock bits can be preset, too. Please refer <<#SECTION_3_5_4, Summary of Table, Register, and Field Locks>> for all lock bits.
