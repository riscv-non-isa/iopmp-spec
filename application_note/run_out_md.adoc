
=== Run Out Memory Domains
In IOPMP specification, the support is capped at 63 memory domains. However, this section provides customization recommendations for situations that necessitate a larger number of memory domains.

==== Parallel IOPMP

Placing multiple IOPMP instances in parallel is a strategy to address two distinct system-level goals: (1) to scale beyond the 63-Memory Domain limit, and (2) to increase the aggregate *transaction checking throughput*.

By partitioning the system, multiple IOPMPs can operate concurrently. This arrangement is highly beneficial for complex SoCs that must handle a large number of simultaneous transactions. A routing mechanism must be placed in front of the parallel IOPMPs to direct an incoming transaction to its designated IOPMP for checking. This routing can be based on the transaction's address (address-based routing) or its RRID (RRID-based routing).

==== Cascading IOPMP

The cascading model is a powerful architecture for enabling *hierarchical security* in large, modular systems. It is particularly well-suited for integrating multiple, independently developed SoCs or subsystems, where each subsystem manages its own internal security policies.

In this policy, a transaction may traverse more than one IOPMP. An IOPMP at the boundary of a subsystem, referred to as an "IOPMP gateway," performs the initial check. Upon a successful check, it tags the outgoing transaction with a new, subsystem-level RRID.

This new RRID effectively represents that the transaction has been checked by its originating subsystem. Subsequent, outer-level IOPMPs can then manage permissions from a higher, more abstract "subsystem perspective" instead of needing to manage rules for every individual initiator within that subsystem. This approach hides internal subsystem details, which is good for protecting intellectual property, and makes the overall system design more abstract, reusable, and modular.

To support this "IOPMP gateway" functionality, `HWCFG3.rrid_transl_en` should be set to 1, and `HWCFG3.rrid_transl` is used to store the RRID to be tagged. `HWCFG3.rrid_transl_prog` indicates whether `HWCFG3.rrid_transl` is programmable or not. To lock `HWCFG3.rrid_transl`, write 1 to `HWCFG3.rrid_transl_prog`, which clears `HWCFG3.rrid_transl_prog` and is sticky to 0.

[cols="<2,<1,<1,<1,<6"]
|===
5+h|HWCFG3{set:cellbgcolor:#D3D3D3}
5+h|0x0014
h|Field |Bits |R/W |Default |Description
|{set:cellbgcolor:#FFFFFF} `rrid_transl_en` |14:14 |R |IMP |Indicate if tagging a new RRID on the initiator port is supported.
|`rrid_transl_prog` |15:15 |W1CS |IMP |A write-1-clear bit that is sticky to 0. Indicates if the `rrid_transl` field is programmable. Supported only for `rrid_transl_en`=1, otherwise, wired to 0.
|`rrid_transl` |31:16 |WARL |IMP |The RRID tagged to outgoing transactions. Supported only for `rrid_transl_en`=1. It is writable only when `rrid_transl_prog`=1.
|===
