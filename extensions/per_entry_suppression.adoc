[#PEIS_PEES]
=== Per-entry Interrupt/Bus Error Suppression

This extension provides a fine-grained, per-entry mechanism to selectively suppress interrupt triggers and bus error responses for specific access violations.

In modern high-performance systems, I/O agents may employ aggressive speculative prefetching to improve performance. While beneficial, these prefetchers may speculatively access memory locations just outside their intended operational regions, such as "guard regions" or adjacent memory boundaries.

If these guard regions are protected by an IOPMP entry (which is a correct and secure configuration), the speculative prefetch would be correctly identified as a violation. However, this "benign" violation can lead to a flood of unnecessary interrupt alarms and bus errors, creating significant system noise and increasing the burden on the secure monitor.

The per-entry suppression extension addresses this problem. It allows software to define these known guard regions with specific IOPMP entries and then set flags (e.g., `sire`, `sere`) to suppress the interrupt and bus error for violations at that specific entry. This ensures that speculative prefetches do not stall the system or generate false alarms, while still preventing access to truly illegal content and without adding interference to the system.

The per-entry suppression extension only extends the error reactions, which are triggered when an entry is matched but does not grant transaction permission to operate.

==== Interrupt Suppression
The bit `peis` in register `HWCFG2` (<<#REG_EXT_HWCFG2,Hardware Configuration 2>>) indicates whether the IOPMP supports per-entry interrupt suppression. If `HWCFG2.peis` is 1, every entry _i_ has three interrupt suppression bits, `sire`, `siwe`, `sixe`, in register `ENTRY_CFG(_i_)` (<<#REG_EXT_ENTRY_CFG,Entry _i_ Configuration with All Extensions>>).
The bits suppress interrupt triggering due to illegal read access, illegal writes access/AMO and illegal instruction fetch respectively.

When an illegal transaction occurs with error type "illegal read access" (0x01), "illegal write access/AMO" (0x02), or "illegal instruction fetch" (0x03), an interrupt is triggered if the global interrupt is enabled (`ERR_CFG.ie`) and not suppressed by `sire`, `siwe`, or `sixe`. Considering Entry _i_ matches an illegal transaction, the condition for the interrupt for each type of illegal access can be described as follows: 

* Illegal read access (0x01): +
`ERR_CFG.ie && !ENTRY_CFG(_i_).sire`
* Illegal write access/AMO (0x02): +
`ERR_CFG.ie && !ENTRY_CFG(_i_).siwe`
* Illegal instruction fetch (0x03): +
`ERR_CFG.ie && !ENTRY_CFG(_i_).sixe`

Where `!` represents logical NOT, and `&&` represents logical AND.

==== Bus Error Suppression
The bit `pees` in register `HWCFG2` (<<#REG_EXT_HWCFG2,Hardware Configuration 2>>) indicates whether the IOPMP supports per-entry bus error suppression. If `HWCFG2.pees` is 1, every entry _i_ has three interrupt suppression bits, `sere`, `sewe`, `sexe`, in register `ENTRY_CFG(_i_)` (<<#REG_EXT_ENTRY_CFG,Entry _i_ Configuration with All Extensions>>).
The bits suppress bus error due to illegal read access, illegal writes access/AMO and illegal instruction fetch respectively.

When an illegal transaction occurs with error type "illegal read access" (0x01), "illegal write access/AMO" (0x02), or "illegal instruction fetch" (0x03), an IOPMP responds bus error if the bus error is not suppressed by `ERR_CFG.rs` and corresponding per-entry suppression bit. `rs` globally suppresses returning a bus error on illegal access. When global suppression is disabled, individual per-entry suppression is possible using `sere`, `sewe`, and `sexe` in `ENTRY_CFG(_i_)` for illegal read access, illegal write access/AMO, and illegal instruction fetch, respectively. Considering Entry _i_ matches an illegal transaction, the condition for a bus error response for each access type can be described as follows:

* Illegal read access (0x01): +
`!ERR_CFG.rs && !ENTRY_CFG(_i_).sere`
* Illegal write access/AMO (0x02): +
`!ERR_CFG.rs && !ENTRY_CFG(_i_).sewe`
* Illegal instruction fetch (0x03): +
`!ERR_CFG.rs && !ENTRY_CFG(_i_).sexe`

Where `!` represents logical NOT, and `&&` represents logical AND.

==== Per-entry Suppression on Non-priority Entries
An IOPMP may match multiple entries when it supports xref:NON_PRIORITY_ENTRIES[xrefstyle=full]. To suppress interrupt, all matching entries must suppress interrupt together. Similarly, to suppress bus error response, all matching entries also must suppress bus error response together. The following describes the detailed relation.

For the cases with multiple matched non-priority entries indexed by _i_~0~, _i_~1~, …​, _i~N~_ , the condition of per-entry interrupt suppression is:

* Illegal read access (0x01): +
`ERR_CFG.ie && ( !ENTRY_CFG(_i_~0~).sire || !ENTRY_CFG(_i_~1~).sire || ... || !ENTRY_CFG(_i~N~_).sire )`
* Illegal write access/AMO (0x02): +
`ERR_CFG.ie && ( !ENTRY_CFG(_i_~0~).siwe || !ENTRY_CFG(_i_~1~).siwe || ... || !ENTRY_CFG(_i~N~_).siwe )`
* Illegal instruction fetch (0x03): +
`ERR_CFG.ie && ( !ENTRY_CFG(_i_~0~).sixe || !ENTRY_CFG(_i_~1~).sixe || ... || !ENTRY_CFG(_i~N~_).sixe )`

The condition of per-entry bus error response suppression is:

* Illegal read access (0x01): + 
`!ERR_CFG.rs && ( !ENTRY_CFG(_i_~0~).sere || !ENTRY_CFG(_i_~1~).sere || ... || !ENTRY_CFG(_i~N~_).sere )`
* Illegal write access/AMO (0x02): +
`!ERR_CFG.rs && ( !ENTRY_CFG(_i_~0~).sewe || !ENTRY_CFG(_i_~1~).sewe || ... || !ENTRY_CFG(_i~N~_).sewe )`
* Illegal instruction fetch (0x03): +
`!ERR_CFG.rs && ( !ENTRY_CFG(_i_~0~).sexe || !ENTRY_CFG(_i_~1~).sexe || ... || !ENTRY_CFG(_i~N~_).sexe )`

Where `!` represents logical NOT, `||` represents logical OR, and `&&` represents logical AND.