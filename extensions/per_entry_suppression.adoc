[#PEIS_PEES]
=== Per-entry Interrupt/Bus Error Suppression

This extension provides a fine-grained, per-entry mechanism to selectively suppress interrupt triggers and bus error responses for specific access violations.

In modern high-performance systems, I/O agents may employ aggressive speculative prefetching to improve performance. While beneficial, these prefetchers may speculatively access memory locations just outside their intended operational regions, such as "guard regions" or adjacent memory boundaries.

If these guard regions are protected by an IOPMP entry (which is a correct and secure configuration), the speculative prefetch would be correctly identified as a violation. However, this "benign" violation can lead to a flood of unnecessary interrupt alarms and bus errors, creating significant system noise and increasing the burden on the secure monitor.

The per-entry suppression extension addresses this problem. It allows software to define these known guard regions with specific IOPMP entries and then set flags (e.g., `sire`, `sere`) to suppress the interrupt and bus error for violations at that specific entry. This ensures that speculative prefetches do not stall the system or generate false alarms, while still preventing access to truly illegal content and without adding interference to the system.

The per-entry suppression extension only extends the error reactions, which are triggered when an entry is matched but does not grant transaction permission to operate.

==== Interrupt Suppression
`HWCFG2.peis` indicates whether the IOPMP supports per-entry interrupt suppression. If `HWCFG2.peis` is 1, every entry _i_ has two interrupt suppression bits, `sire`, `siwe`, in register `ENTRY_CFG(_i_)`. The bits suppress interrupt triggering due to illegal read access and illegal writes access/AMO respectively.

If an IOPMP can check instruction fetch permission (<<X_PERM>>) and support per-entry interrupt suppression (`HWCFG2.chk_x` = 1 and `HWCFG2.peis` = 1), every entry _i_ has one additional interrupt suppression bit, `sixe`, in register `ENTRY_CFG(_i_)`. It suppresses interrupt triggering due to illegal instruction fetch.

When an illegal transaction occurs with error type "illegal read access" (0x01), "illegal write access/AMO" (0x02), or "illegal instruction fetch" (0x03), an interrupt is triggered if the global interrupt is enabled (`ERR_CFG.ie`) and not suppressed by `sire`, `siwe`, or `sixe`. Considering Entry _i_ matches an illegal transaction, the condition for the interrupt for each type of illegal access can be described as follows: 

* Illegal read access (0x01): +
`ERR_CFG.ie && !ENTRY_CFG(_i_).sire`
* Illegal write access/AMO (0x02): +
`ERR_CFG.ie && !ENTRY_CFG(_i_).siwe`
* Illegal instruction fetch (0x03): +
`ERR_CFG.ie && !ENTRY_CFG(_i_).siwe`

Where `!` represents logical NOT, and `&&` represents logical AND.

==== Bus Error Suppression
`HWCFG2.pees` indicates whether the IOPMP supports per-entry bus error suppression. If `HWCFG2.pees` is 1, every entry _i_ has two interrupt suppression bits, `sere`, `sewe`, in register `ENTRY_CFG(_i_)`. The bits suppress bus error due to illegal read access and illegal writes access/AMO respectively.

If an IOPMP can check instruction fetch permission (<<X_PERM>>) and support per-entry bus error suppression (`HWCFG2.chk_x` = 1 and `HWCFG2.pees` = 1), every entry _i_ has one additional bus error suppression bit, `sexe`, in register `ENTRY_CFG(_i_)`. It suppresses bus error due to illegal instruction fetch.

When an illegal transaction occurs with error type "illegal read access" (0x01), "illegal write access/AMO" (0x02), or "illegal instruction fetch (0x03)", an IOPMP responds bus error if the bus error is not suppressed by `ERR_CFG.rs` and corresponding per-entry suppression bit. `rs` globally suppresses returning a bus error on illegal access. When global suppression is disabled, individual per-entry suppression is possible using `sere`, `sewe`, and `sexe` in `ENTRY_CFG(_i_)` for illegal read access, illegal write access/AMO, and illegal instruction fetch, respectively. Considering Entry _i_ matches an illegal transaction, the condition for a bus error response for each access type can be described as follows:

* Illegal read access (0x01): +
`!ERR_CFG.rs && !ENTRY_CFG(_i_).sere`
* Illegal write access/AMO (0x02): +
`!ERR_CFG.rs && !ENTRY_CFG(_i_).sewe`
* Illegal instruction fetch (0x03): +
`!ERR_CFG.rs && !ENTRY_CFG(_i_).sexe`

Where `!` represents logical NOT, and `&&` represents logical AND.

==== Per-entry Suppression on Non-priority Entries
An IOPMP may match multiple entries when it supports xref:NON_PRIORITY_ENTRIES[xrefstyle=full]. To suppress interrupt, all matching entries must suppress interrupt together. Similarly, to suppress bus error response, all matching entries also must suppress bus error response together. The following describes the detailed relation.

For the cases with multiple matched non-priority entries indexed by _i_~0~, _i_~1~, …​, _i~N~_ , the condition of per-entry interrupt suppression is:

* Illegal read access (0x01): +
`ERR_CFG.ie && ( !ENTRY_CFG(_i_~0~).sire || !ENTRY_CFG(_i_~1~).sire || ... || !ENTRY_CFG(_i~N~_).sire )`
* Illegal write access/AMO (0x02): +
`ERR_CFG.ie && ( !ENTRY_CFG(_i_~0~).siwe || !ENTRY_CFG(_i_~1~).siwe || ... || !ENTRY_CFG(_i~N~_).siwe )`
* Illegal instruction fetch (0x03): +
`ERR_CFG.ie && ( !ENTRY_CFG(_i_~0~).sixe || !ENTRY_CFG(_i_~1~).sixe || ... || !ENTRY_CFG(_i~N~_).sixe )`

The condition of per-entry bus error response supression is:

* Illegal read access (0x01): + 
`!ERR_CFG.rs && ( !ENTRY_CFG(_i_~0~).sere || !ENTRY_CFG(_i_~1~).sere || ... || !ENTRY_CFG(_i~N~_).sere )`
* Illegal write access/AMO (0x02): +
`!ERR_CFG.rs && ( !ENTRY_CFG(_i_~0~).sewe || !ENTRY_CFG(_i_~1~).sewe || ... || !ENTRY_CFG(_i~N~_).sewe )`
* Illegal instruction fetch (0x03): +
`!ERR_CFG.rs && ( !ENTRY_CFG(_i_~0~).sexe || !ENTRY_CFG(_i_~1~).sexe || ... || !ENTRY_CFG(_i~N~_).sexe )`

Where `!` represents logical NOT, `||` represents logical OR, and `&&` represents logical AND.

==== Register(s) and Field(s)

[cols="<2,<1,<1,<1,<6"]
|===
5+h|HWCFG2{set:cellbgcolor:#D3D3D3}
5+h|0x0008
h|Field                         |Bits   |R/W    |Default    |Description
|{set:cellbgcolor:#FFFFFF}
`peis`                          |27:27  |R      |IMP        |Indicate if the IOPMP implements interrupt suppression per entry, including fields `sire` and `siwe` in `ENTRY_CFG(_i_)`, _i_ = 0...`HWCFG1.entry_num`-1.
|`pees`                         |28:28  |R      |IMP        |Indicate if the IOPMP implements the error suppression per entry, including fields `sere` and `sewe` in `ENTRY_CFG(_i_)`, _i_ = 0...`HWCFG1.entry_num`-1.
|===

[cols="<2,<1,<1,<1,<6"]
|===
5+h|{set:cellbgcolor:#D3D3D3} ENTRY_CFG(_i_), _i_ = 0...`HWCFG1.entry_num`-1
5+h|ENTRYOFFSET + 0x8 + (_i_) × 16
h|Field                         |Bits       |R/W       |Default    |Description
|{set:cellbgcolor:#FFFFFF}
`sire`                          |5:5        |WARL      |IMP        |Suppress interrupt for an illegal read access caught by the entry.
|`siwe`                         |6:6        |WARL      |IMP        |Suppress interrupt for an illegal write access/AMO caught by the entry.
|`sixe`                         |7:7        |WARL      |IMP        |Suppress interrupt on an illegal instruction fetch caught by the entry.
|`sere`                         |8:8        |WARL      |IMP       a|Suppress the (bus) error on an illegal read access caught by the entry:

* 0x0: respond an error if `ERR_CFG.rs` is 0x0. 
* 0x1: do not respond an error. User to define the behavior, e.g., respond a success with an implementation-dependent value to the initiator.

|`sewe`                         |9:9        |WARL      |IMP       a|Suppress the (bus) error on an illegal write access/AMO caught by the entry:

* 0x0: respond an error if `ERR_CFG.rs` is 0x0. 
* 0x1: do not respond an error. User to define the behavior, e.g., respond a success if response is needed
|`sexe`                         |10:10      |WARL      |IMP       a|Suppress the (bus) error on an illegal instruction fetch caught by the entry:

* 0x0: respond an error if `ERR_CFG.rs` is 0x0.
* 0x1: do not respond an error. User to define the behavior, e.g., respond a success with an implementation-dependent value to the initiator.
|===