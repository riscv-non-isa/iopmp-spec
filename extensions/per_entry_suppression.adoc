[#PEIS_PEES]
=== Per-entry Interrupt/Bus Error Suppression

The extension provides a per-entry control mechanism. It can be beneficial in scenarios such as configuring guard regions that a prefetch may incidentally access but should not access. Suppressing such interrupts and bus error responses can reduce the unnecessary burden of unwanted interruptions and bus error responses.

==== Interrupt Suppression
*HWCFG2.peis* indicates whether the IOPMP supports per-entry interrupt suppression. If *HWCFG2.peis* is 1, every entry _i_ has two interrupt suppression bits, *sire*, *siwe*, in register *ENTRY_CFG(_i_)*. The bits suppress interrupt triggering due to illegal read access and illegal writes access/AMO respectively.
//If *peis* is 0, *sire* and *siwe* should be wired to 0.

If an IOPMP can check instruction fetch permission and support per-entry interrupt suppression (*HWCFG2.chk_x* = 1 and *HWCFG2.peis* = 1), every entry _i_ has one additional interrupt suppression bit, *sixe*, in register *ENTRY_CFG(_i_)*. It suppresses interrupt triggering due to illegal instruction fetch.
//If *peis* is 0, *sixe* should be wired to 0.

When an illegal transaction occurs with error type "illegal read access" (0x01), "illegal write access/AMO" (0x02), or "illegal instruction fetch" (0x03), an interrupt is triggered if the global interrupt is enabled (*ERR_CFG.ie*) and not suppressed by *sire*, *siwe*, or *sixe*. Considering Entry _i_ matches an illegal transaction, the condition for the interrupt for each type of illegal access can be described as follows: 

* Illegal read access (0x01): +
*ERR_CFG.ie* && !*ENTRY_CFG(_i_).sire* 
* Illegal write access/AMO (0x02): +
*ERR_CFG.ie* && !*ENTRY_CFG(_i_).siwe*
* Illegal instruction fetch (0x03): +
*ERR_CFG.ie* && !*ENTRY_CFG(_i_).siwe*

Where ! represents logical NOT, and && represents logical AND.

When an illegal transaction occurs with error type "Partial hit on a priority rule" (0x04), "Not hit any rule" (0x05), or "Unknown RRID" (0x06), an IOPMP triggers an interrupt only if *ie* = 1. 

==== Bus Error Suppression
*HWCFG2.pees* indicates whether the IOPMP supports per-entry bus error suppression. If *HWCFG2.pees* is 1, every entry _i_ has two interrupt suppression bits, *sere*, *sewe*, in register *ENTRY_CFG(_i_)*. The bits suppress bus error due to illegal read access and illegal writes access/AMO respectively.

If an IOPMP can check instruction fetch permission and support per-entry bus error suppression (*HWCFG2.chk_x* = 1 and *HWCFG2.pees* = 1), every entry _i_ has one additional bus error suppression bit, *sexe*, in register *ENTRY_CFG(_i_)*. It suppresses bus error due to illegal instruction fetch.

When an illegal transaction occurs with error type "illegal read access" (0x01), "illegal write access/AMO" (0x02), or "illegal instruction fetch (0x03)", an IOPMP responds bus error if the bus error is not suppressed by *ERR_CFG.rs* and corresponding per-entry suppression bit. *rs* globally suppresses returning a bus error on illegal access. When global suppression is disabled, individual per-entry suppression is possible using *sere*, *sewe*, and *sexe* in *ENTRY_CFG(_i_)* for illegal read access, illegal write access/AMO, and illegal instruction fetch, respectively. Considering Entry _i_ matches an illegal transaction, the condition for a bus error response for each access type can be described as follows:

* Illegal read access (0x01): +
!*ERR_CFG.rs* && !*ENTRY_CFG(_i_).sere* 
* Illegal write access/AMO (0x02): +
!*ERR_CFG.rs* && !*ENTRY_CFG(_i_).sewe*
* Illegal instruction fetch (0x03): +
!*ERR_CFG.rs* && !*ENTRY_CFG(_i_).sexe*

Where ! represents logical NOT, and && represents logical AND.

When an illegal transaction occurs with error type "Partial hit on a priority rule" (0x04), "Not hit any rule" (0x05), or "Unknown RRID" (0x06), an IOPMP responds bus error only if *rs* = 0. 

==== Per-entry Suppression on Non-priority Entries
An IOPMP may match multiple entries when it supports xref:NON_PRIORITY_ENTRIES[xrefstyle=full]. To suppress interrupt, all matching entries must suppress interrupt together. Similarly, to suppress bus error response, all matching entries also must suppress bus error response together. The following describes the detailed relation.

For the cases with multiple matched non-priority entries indexed by _i_~0~, _i_~1~, …​, _i~N~_ , the condition of per-entry interrupt suppression is:

* Illegal read access (0x01): +
*ERR_CFG.ie* && ( !*ENTRY_CFG(_i_~0~).sire* || !*ENTRY_CFG(_i_~1~).sire* || ... || !*ENTRY_CFG(_i~N~_).sire* )
* Illegal write access/AMO (0x02): +
*ERR_CFG.ie* && ( !*ENTRY_CFG(_i_~0~).siwe* || !*ENTRY_CFG(_i_~1~).siwe* || ... || !*ENTRY_CFG(_i~N~_).siwe* )
* Illegal instruction fetch (0x03): +
*ERR_CFG.ie* && ( !*ENTRY_CFG(_i_~0~).sixe* || !*ENTRY_CFG(_i_~1~).sixe* || ... || !*ENTRY_CFG(_i~N~_).sixe* )

The condition of per-entry bus error response supression is:

* Illegal read access (0x01): + 
!*ERR_CFG.rs* && ( !*ENTRY_CFG(_i_~0~).sere* || !*ENTRY_CFG(_i_~1~).sere* || ... || !*ENTRY_CFG(_i~N~_).sere* )
* Illegal write access/AMO (0x02): +
!*ERR_CFG.rs* && ( !*ENTRY_CFG(_i_~0~).sewe* || !*ENTRY_CFG(_i_~1~).sewe* || ... || !*ENTRY_CFG(_i~N~_).sewe* )
* Illegal instruction fetch (0x03): +
!*ERR_CFG.rs* && ( !*ENTRY_CFG(_i_~0~).sexe* || !*ENTRY_CFG(_i_~1~).sexe* || ... || !*ENTRY_CFG(_i~N~_).sexe* )

Where ! represents logical NOT, || represents logical OR, and && represents logical AND.