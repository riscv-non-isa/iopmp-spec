[[Concepts]]
== Terminology and Concepts

This document refers to the term “secure monitor” as the software responsible for managing security-related tasks, including the programming of IOPMPs. The secure monitor is not restricted to operating on a single CPU or hart; instead, it may be distributed across multiple CPUs.

.Glossary and Acronyms
[%autowidth, cols="<1,<3", options="header"]
|===
|Term |Description
|AMO| atomic memory operation
|DC| don't care
|DMA| direct memory access
|DRAM| dynamic random-access memory
|ID| identifier
|IMP|implementation-dependent
|IOMMU| Input-Output Memory Management Unit cite:[IOMMU], a RISC-V non-ISA specification
|MD| memory domain
|MMIO|memory mapped input/output devices
|NA4|naturally aligned four-byte region, one of the address matching mode used in RISC-V PMP cite:[PrivISA] and IOPMP
|NAPOT|naturally aligned power-of-2 region, one of the address matching mode used in RISC-V PMP cite:[PrivISA] and IOPMP
|N/A| not available
|RRID| Request Role ID
|RX|receiver
|TOR|top boundary of an arbitrary range, one of the address matching mode used in RISC-V PMP cite:[PrivISA] and IOPMP
|TX|transmitter
|WARL|write any read legal, a behavior of fields
|W1C|write '1' clear, a behavior of single bit fields
|W1CS|write '1' clear and sticky to 0, a behavior of single bit fields: writing '1' clears the bit. If the bit is cleared, this state remains fixed until IOPMP registers are reset.
|W1S|write '1' set, a behavior of single bit fields
|W1SS|write '1' set and sticky to 1, a behavior of single bit fields: writing '1' sets the bit. If the bit is set, this state remains fixed until IOPMP registers are reset.
|X( _n_ )|the _n_-th register in the register array X, which starts from 0.
|X[ _n_ ]|the _n_-th bit of a register X or register field X
|X( _n_ : _m_ )|the _n_-th to _m_-th registers of a register X.
|X[ _n_ : _m_ ]|the _n_-th to _m_-th bits of a register X or register field X.
|===

=== Request-Role-ID and Transaction
Request Role ID, RRID for short, is a unique ID to identify a system-defined security context. For example, a unique RRID can be a transaction requestor or a group of transaction requestors with the same permission. Depending on the IOPMP integration, transactions may be tagged with an RRID to identify the requestor. Tagging requestors with RRID is implementation-dependent. The number of bits of an RRID is implementation-dependent as well. If different channels or modes of a requestor could be granted different access permissions, they can have their own RRID.

// NOTE: The "Source-Enforcement" section was removed as part of the specification simplification.
// This section described IOPMP-SE (source enforcement) where RRID could be ignored
// for single requestor scenarios, but is no longer supported in the simplified specification.

=== Requestor Port, Receiver Port and Control Port
An IOPMP has one or multiple requestor ports, one or multiple receiver ports and one control port. A receiver port is where a transaction goes into the IOPMP, and a requestor port is where a transaction leaves it if the transaction passes all the checks. The control port is used to program the IOPMP.

=== Memory Domain
// NOTE: This section was simplified as part of the specification simplification.
// Only full model is described in the section.
An RRID is an abstract representation of a transaction requestor. It encompasses one or more transaction requestors that are granted identical permissions. A memory domain, MD for short, is an abstract representation of a transaction destination that groups a set of memory regions for a specific purpose. MDs are indexed from zero. For example, a network interface controller, NIC, may have three memory regions: an RX region, a TX region, and a region of control registers. We could group them into one MD. If a processor can fully control the NIC, the processor can be associated with the MD.

It’s important to note that, generally speaking, a single RRID can be associated with multiple memory domains (MDs), and a MD can be associated with multiple RRIDs. SRCMD Table is a one of fundamental structures in IOPMP to indicate associations between RRIDs and MDs, which will be introduced in <<#SRCMD_TABLE, SRCMD Table>>.

MDCFG Table also is one of fundamental structures in IOPMP to define a set of memory regions in a MD, which will be introduced in <<#MDCFG_TABLE, MDCFG Table>>. An IOPMP entry defines a single memory region, which will be introduced in <<#IOPMP_ENTRY, IOPMP Entry and IOPMP Entry Array>>. 

An RRID associated with a MD may not have full permissions on all memory regions of the MD, because the permission of each region is defined in the corresponding IOPMP entry.


[#IOPMP_ENTRY]
=== IOPMP Entry and IOPMP Entry Array
The IOPMP entry array, contains *HWCFG1.entry_num* IOPMP entries, where the value zero is reserved. Each entry, starting from an index of zero, includes a specified memory region, the corresponding permissions, and optional features about error reactions and user customized attributes.

For an entry indexed by _i_, *ENTRY_ADDR(_i_)*, *ENTRY_ADDRH(_i_)* and *ENTRY_CFG(_i_).a* encode the memory region in the same way as the RISC-V PMP. *ENTRY_ADDR(_i_)* and *ENTRY_ADDRH(_i_)* are the encoded address for the IOPMP with addresses greater than 34 bits. For addresses less than and equal to 34 bits, only *ENTRY_ADDR(_i_)* is in use. To determine whether *ENTRY_ADDRH(_i_)* are implemented, one can check *HWCFG0.addrh_en*. Please refer <<#HWCFG0, HWCFG0>> for more details of *HWCFG0.addrh_en*. *ENTRY_CFG(_i_).a* is the address mode, which are OFF, NA4, NAPOT, and TOR. Please refer to the RISC-V privileged spec cite:[PrivISA] for the details of the encoding schemes. *HWCFG0.tor_en* = 1 indicates the IOPMP supports TOR address mode.

[NOTE]
====
Since the address encoding scheme of TOR refers to the previous entry's memory region, which is not in the same memory domain, it would cause unexpected results. If the first entry of a memory domain selects TOR, the entry refers to the previous memory domain. When the previous memory domain is changed unexpectedly, the region of this entry will be altered. To prevent the unexpected change of memory region, software should

* avoid adopting TOR for the first entry of a memory domain; or 
* set an OFF for the last entry of a memory domain with the maximal address during programming the IOPMP.
====

// NOTE: This section was simplified as part of the specification simplification.
// Removed references to instruction fetch permission (x bit), chk_x field, and ENTRY_USER_CFG register.
// Only basic read/write permissions and address mode configuration are now supported.

*ENTRY_CFG(_i_).r/w* indicate the read access and write access permission and they are WARL. That is, an implementation can decide which bits are programmable or hardwired and which bit combinations are unwanted.

*ENTRY_CFG(_i_)* contains the basic permission fields for read, write, and address mode configuration.

// NOTE: The original description of ENTRY_USER_CFG(_i_) register was removed here
// as part of the specification simplification. This register stored customized attributes
// for entries and was controlled by HWCFG0.user_cfg_en, but is no longer supported.

// NOTE: The following section describes entry availability based on HWCFG1.entry_num,
// which is one of the fields retained in the simplified specification.

Any entry with index &#8805; *HWCFG1.entry_num* is not available. That is,

* Registers of the entry are not implemented.
* Address mode of the entry is treated as OFF when the IOPMP retrieves the entry in permission checks.

Memory domains are a way of dividing the IOPMP entry array into different subarrays. Each subarray is a memory domain. Each IOPMP entry can belong to at most one memory domain, while a memory domain could have multiple IOPMP entries. 

[NOTE]
====
A memory domain may have an IOPMP entry with index &#8805; *HWCFG1.entry_num* due to its register encoding or implementation. The entry is not available.
====

When an RRID is associated with a memory domain, it is also inherently associated with all the entries that belong to that memory domain.

// NOTE: The original description of HWCFG0.no_w and HWCFG0.no_x fields was removed here
// as part of the specification simplification. These fields were used to deny write
// transactions and instruction fetch transactions globally, but are no longer supported.

=== Priority and Matching Logic
// NOTE: This section was simplified as part of the specification simplification.
// Removed references to no_w/no_x fields, per-entry interrupt suppression (sire/siwe/sixe),
// and complex multi-entry matching logic. Only global error reactions are now supported.

The IOPMP uses entry-based permission checking to determine whether transactions are allowed or denied.

When a transaction arrives at an IOPMP, the IOPMP first checks whether the RRID carried by the transaction is legal. If the RRID is illegal, the transaction is illegal with error type = "Unknown RRID" (0x06)".

NOTE: Whether an RRID is legal is implementation-dependent, even though it < *HWCFG1.rrid_num*.

IOPMP entries are prioritized according to their index values. Entries with lower indices are assigned a higher priority. When multiple entries match a transaction, the entry with the lowest index (highest priority) takes precedence. 

NOTE: The specification uses priority-based entry matching to provide deterministic behavior. Entries with lower indices have higher priority and take precedence when multiple entries match a transaction. Non-prioritized entries are supported for specific use cases, with their detailed behavior documented in the application notes.

An entry qualifies as a matching entry for an incoming transaction if:

* Its region covers any byte of the transaction,
* It is associated with the RRID carried by the transaction; and
* It holds the highest priority among entries that meet the previous criteria.

[NOTE]
====
When multiple entries match a transaction, the entry with the lowest index (highest priority) is selected.
====

Matched entries can grant a transaction according to its access type. If the matching entry allows the access type, the transaction is legal. Every entry can permit read and write access by its *r* and *w* bits, respectively.

The matching entry must match all bytes of a transaction, or the transaction is illegal with error type = "partial hit on a priority rule" (0x04), irrespective of its permission. If an entry is matched but doesn't grant transaction permission to operate, the transaction is illegal with error type = "illegal read access" (0x01) for read access transaction, "illegal write access/AMO" (0x02) for write access/atomic memory operation (AMO) transaction.

Finally, if no matching entry exists, the transaction is illegal with error type = "not hit any rule" (0x05).

[NOTE]
====
To grant an AMO transaction permission, entries and/or memory domains must have read access permission and write access permission.
====

[NOTE]
====
Some AMO implementations of I/O agents are using a non-atomic read-modify-write sequence which could contain a read access transaction and a write access transaction, not single AMO transaction. Therefore, IOPMP possiblly captures error type = "illegal read access" (0x01) when read permission for the read-modify-write sequence from the I/O agents is not granted.
====

[#IOPMP_BLOCK_DIAGRAM]
.an example block diagram of an IOPMP. It illustrates the checking flow of an IOPMP. This IOPMP takes three inputs: RRID, the transaction type (read/write), and the request range (address/len). It first looks up the SRCMD Table according to the RRID carried by the incoming transaction to retrieve associated MD indexes. By the MD indexes, the IOPMP looks up the MDCFG Table to get the belonging entry indexes. The final step checks the access right according to the above entry indexes and corresponding permissions. An interrupt, an error response, and/or a record is generated once the transaction fails the permission check in the step.
image::images/iopmp_unit_block_diagram.png[]

=== Error Reactions
// NOTE: This section was significantly simplified as part of the specification simplification.
// Removed instruction fetch error handling (error type 0x03), per-entry error suppression fields
// (sire/siwe/sixe/sere/sewe/sexe), and complex multi-entry error logic.
// Only global error reactions via ERR_CFG are now supported.

Upon detecting an illegal transaction, the IOPMP could initiate three of the following actions: 

* Trigger an interrupt to notify the system of the violation.

* Return bus error (or a decode error) or not with an implementation-defined value. 

* Log the error details in IOPMP error record registers.

IOPMP can trigger an interrupt on an access violation. The *ERR_CFG.ie* bit serves as the global interrupt enable configuration bit. The interrupt pending indication is equivalent to the error valid indication; both are flagged through the *ERR_INFO.v* bit. On an illegal transaction, an interrupt is triggered if the global interrupt is enabled (*ERR_CFG.ie* = 1). The condition for the interrupt can be described as follows: 

* Illegal read access (0x01): *ERR_CFG.ie* = 1
* Illegal write access/AMO (0x02): *ERR_CFG.ie* = 1

For illegal transactions, the interrupt is triggered when *ERR_CFG.ie* is set.

Transactions that violate the IOPMP rule will by default yield a bus error. The bus error response behavior on an IOPMP violation can be configured globally via the *ERR_CFG* register. The IOPMP will signal the bus to the presence of a violation but will suppress the bus error if *ERR_CFG.rs* is implemented and set to 1 on a violation. User-defined suppression behavior allows, for example, a read response of 0x0. 

The bus error response behavior is controlled by the global bus error response suppression configuration bit *ERR_CFG.rs*. An IOPMP will respond with a bus error when a transaction is illegal and the bus error is not suppressed. The condition for a bus error response can be described as follows:  

* Illegal read access (0x01): !*ERR_CFG.rs*
* Illegal write access/AMO (0x02): !*ERR_CFG.rs*


The error capture record maintains the specifics of the first illegal access detected, except for the condition:

* no interrupt regarding the access is triggered, and
* no bus error is returned.

An error capture only occurs when there is no pending error, that is, *ERR_INFO.v* = ‘0’. If a pending error exists (*v* = ‘1’), the record will not be updated, even if a new illegal access is detected. In other words, *v*  indicates whether the content of the capture record is valid and should be intentionally cleared in order to capture subsequent illegal accesses. One can write 1 to the bit to clear it. The error capture record is optional. If it is not implemented, *v* should be wired to zero. One can implement the error capture record, but doesn't implement the error entry index record (*ERR_REQID.eid*). In this case, *eid* should be wired to 0xffff.

The following table shows all error types and corredponding control bits of error reaction in this specification:

.Error types and corresponding control bits
[%autowidth, cols="<1,<5,<3", options="header"]
|===
 2+| Error type | Control bits
   |0x00        | No error                          | N/A
   |0x01        | Illegal read access               | *ie* and *rs* ^1.^
   |0x02        | Illegal write access/AMO          | *ie* and *rs*
   |0x03        | illegal instruction fetch         | *ie* and *rs*
   |0x04        | Partial hit on a priority rule    | *ie* and *rs*
   |0x05        | Not hit any rule                  | *ie* and *rs*
   |0x06        | Unknown RRID                      | *ie* and *rs*
   |0x07        | Reserved for future               | reserved
   |0x08 ~ 0x0D | Reserved for future               | reserved
|===

^1.^ Bit *ie* or *rs* in *ERR_CFG*. It depends on which reaction (that is, interrupt or bus error response).
